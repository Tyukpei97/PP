
{
  "projectPath": "C:\\Users\\alext\\Desktop\\ПП\\08.11",
  "language": "C#",
  "framework": ".NET 8.0",
  "ui": "WPF",
  "projectName": "Turing Machine Simulator & Verifier (Interactive Analyzer)",
  "deliverable": "Fully working solution (builds and runs without manual fixes)",
  "criticalUiLanguageRequirement": {
    "mustBeRussian": true,
    "scope": "ALL UI text must be in Russian: window titles, buttons, labels, menus, dialogs, tooltips, status messages, error messages, and any on-screen hints. Do NOT use English anywhere in the interface."
  },
  "constraints": [
    "No database usage.",
    "Must not require administrator privileges.",
    "JSON is allowed ONLY for saving/loading projects (machine + test inputs) as required.",
    "The app must not claim to solve the general halting problem; only practical analyses/heuristics are allowed."
  ],
  "requirements": {
    "goal": "Create a WPF app to visually build a Turing Machine (states, tape alphabet, transitions), edit/load/save a formal program description, run simulation on an input tape with step-by-step visualization, detect looping via repeated configurations, provide execution traces, and compare two machines on a finite set of test inputs.",
    "architecture": {
      "pattern": "MVVM",
      "separation": [
        "Core/Model: Turing machine definition, transition rules, parser, simulator, loop detector, trace recorder, test runner, comparison engine.",
        "ViewModels: observable collections for states/transitions/tape cells, commands for editing and simulation control, validation and status.",
        "Views: WPF Canvas-based state diagram + an ItemsControl-based tape visualization + panels for rules/trace/tests."
      ],
      "suggestedFolders": [
        "Core/Machine (TmDefinition, State, TransitionRule, Alphabet)",
        "Core/Parsing (RuleTokenizer, RuleParser, ImportFormat)",
        "Core/Simulation (TmRunner, StepResult, TapeModel, ConfigurationHasher, LoopDetector)",
        "Core/Analysis (Heuristics, TerminationHints, TraceExporter)",
        "Core/Serialization (JsonProjectSerializer)",
        "UI/ViewModels",
        "UI/Views",
        "UI/Rendering (GraphLayout, EdgeGeometry, TapeRendering)"
      ]
    },
    "tmEditor": {
      "states": {
        "required": true,
        "features": [
          "Add/remove states on a Canvas",
          "Rename state labels (e.g., q0, q1, HALT)",
          "Mark exactly one start state",
          "Mark one or more halting states"
        ],
        "validation": [
          "Must have a start state",
          "Must have at least one halting state",
          "State labels must be unique"
        ]
      },
      "alphabet": {
        "required": true,
        "features": [
          "User defines tape alphabet symbols (e.g., 0, 1, _)",
          "Blank symbol is configurable and defaults to '_'"
        ],
        "validation": [
          "Blank symbol must be in alphabet",
          "Alphabet cannot be empty"
        ]
      },
      "transitions": {
        "required": true,
        "editingModes": [
          "Visual: create directed edges between states and edit rule labels",
          "Text: import/edit formal rules in a text editor panel"
        ],
        "ruleFormat": {
          "canonical": "(q0, 1) -> (q1, 0, R)",
          "labelFormatOnEdge": "read -> write, move (e.g., 1→0,R)",
          "moves": ["L", "R", "S"]
        },
        "determinism": {
          "required": true,
          "default": "Deterministic TM (one rule per (state, readSymbol))",
          "optionalAdvanced": "Allow nondeterministic rules and simulate sets of configurations (not required in MVP)"
        },
        "validation": [
          "For deterministic mode, reject duplicate rules for same (state, readSymbol)",
          "Reject symbols outside alphabet",
          "Reject missing fields or invalid move direction"
        ]
      },
      "autoLayout": {
        "optional": true,
        "feature": "Auto-arrange states to reduce overlaps"
      }
    },
    "tapeAndSimulation": {
      "tapeModel": {
        "required": true,
        "infiniteBothSides": true,
        "implementation": "Sparse tape (Dictionary<long,char>) with blank default; UI shows a sliding window around the head."
      },
      "tapeEditor": {
        "required": true,
        "features": [
          "Input tape string field (e.g., 1101) applied to tape starting at position 0",
          "Head starts at the first symbol (position 0)",
          "Allow editing tape cells in the visible window (optional)"
        ],
        "validation": [
          "Input characters must belong to alphabet (excluding blank if desired)",
          "Show Russian message if invalid"
        ]
      },
      "simulationControls": {
        "required": true,
        "buttonsRu": [
          "Старт",
          "Шаг",
          "Пауза",
          "Продолжить",
          "Сброс",
          "Перемотка (быстро)"
        ],
        "hotkeys": [
          "Space = Пауза/Продолжить",
          "F10 = Шаг",
          "Ctrl+R = Сброс"
        ],
        "speed": {
          "required": true,
          "ui": "Slider (Russian label) controlling delay between steps"
        }
      },
      "visualization": {
        "required": true,
        "features": [
          "Highlight current state on the state graph",
          "Show moving head over the tape with animation (or smooth transition)",
          "Highlight the current tape cell under the head",
          "Show current step number"
        ],
        "statusResult": [
          "Stopped in halting state (accepted/finished)",
          "Loop detected (Russian message: 'Зацикливание обнаружено')",
          "No rule available (halt with error) with Russian explanation"
        ]
      },
      "stepLimit": {
        "required": true,
        "default": 10000,
        "behavior": "If step limit reached without halting/loop proof, stop and report Russian warning (not a proof of non-halting)."
      }
    },
    "behaviorAnalysis": {
      "loopDetection": {
        "required": true,
        "goal": "Detect repeated configurations efficiently.",
        "approach": [
          "Maintain HashSet of configuration hashes for visited configurations.",
          "Configuration includes: current state + head position + tape contents.",
          "Use a stable hashing strategy: sparse tape entries (non-blank cells) serialized deterministically into a hash."
        ],
        "performanceNote": "O(1) average per step insertion/lookup; must handle up to 10,000 steps smoothly."
      },
      "terminationHeuristics": {
        "optionalButRecommended": true,
        "rules": [
          "Provide limited heuristics for simple cases (e.g., monotone head movement over finite non-blank region) but never claim general proof.",
          "Label results clearly in Russian as 'Эвристика' or 'Предположение'."
        ]
      },
      "trace": {
        "required": true,
        "features": [
          "Trace table showing step-by-step: step index, state, read symbol, write symbol, move, head position",
          "Allow export trace to TXT (optional)",
          "Allow jumping to a specific step (optional)"
        ]
      }
    },
    "verificationAndTesting": {
      "testInputs": {
        "required": true,
        "features": [
          "User can define a list of input strings (including empty string)",
          "Run the machine on all inputs and show a results table"
        ],
        "resultColumnsRu": [
          "Вход",
          "Результат (Остановилась/Зациклилась/Лимит шагов/Ошибка)",
          "Шаги",
          "Выход (лента/срез)",
          "Конечное состояние"
        ]
      },
      "compareTwoMachines": {
        "required": true,
        "behavior": [
          "Load/edit two machines (Machine A and Machine B) in the UI (tabs or split view).",
          "Run both machines on the same set of test inputs.",
          "Mark inputs where outputs differ or behavior differs (halt vs loop vs error)."
        ],
        "note": "This is equivalence on a finite test set only (not formal equivalence). Show this clearly in Russian UI."
      }
    },
    "importExport": {
      "textImport": {
        "required": true,
        "format": "One rule per line: (q0, 1) -> (q1, 0, R)",
        "behavior": [
          "Parse rules, validate against alphabet and states (create missing states only if user confirms in UI, or reject with Russian error).",
          "Show line/column on parse errors."
        ]
      },
      "projectSaveLoad": {
        "required": true,
        "format": "JSON",
        "scope": [
          "Machine definition (states, transitions, alphabet, blank symbol, start/halting states, optional positions)",
          "Test input list",
          "Optional: last used tape input"
        ]
      },
      "noDatabase": true
    },
    "robustness": {
      "requirements": [
        "Never crash on invalid rules, missing transitions, malformed JSON, or extreme inputs.",
        "Keep UI responsive during run/fast-forward using background tasks and throttled UI updates."
      ]
    },
    "uiUxRequirementsRu": [
      "Весь интерфейс строго на русском языке: заголовки окон, кнопки, подписи, меню, подсказки, сообщения об ошибках и статус — без английских слов.",
      "Интерфейс должен быть логично разделён: редактор МТ (состояния/переходы), лента и управление симуляцией, таблица трассировки, панель тестов — всё на одном экране или в понятных вкладках.",
      "Запуск должен быть удобным: кнопки «Старт/Шаг/Пауза/Сброс» на виду, скорость регулируется ползунком, есть понятный счётчик шагов.",
      "Лента должна быть читаемой: видимый «окно»-срез вокруг головки, текущая ячейка выделена, перемещение головки визуально заметно.",
      "Ошибки должны объясняться ясно: если нет правила для (состояние, символ) — показывать понятное сообщение на русском, без падений.",
      "Зацикливание должно отображаться явно: сообщение «Зацикливание обнаружено», подсветка шага/конфигурации (если возможно) и остановка выполнения.",
      "Трассировка должна быть полезной: таблица шагов с возможностью прокрутки и (опционально) перехода к шагу, всё с русскими заголовками.",
      "Сравнение двух машин должно быть понятным: вкладки «МТ A» и «МТ B», общая таблица тестов, подсветка различий, и пояснение что сравнение выполняется только на заданных входах.",
      "Никаких налезаний элементов: ровные отступы, выравнивание, единый стиль и читабельные размеры шрифтов."
    ]
  }
}

